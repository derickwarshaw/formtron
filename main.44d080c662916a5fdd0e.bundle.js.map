{"version":3,"file":"main.44d080c662916a5fdd0e.bundle.js","sources":["webpack:///./.storybook/config.js","webpack:///./.storybook/theme.js","webpack:///./src/Formtron.tsx","webpack:///./src/__stories__/ArrayInput.tsx","webpack:///./src/__stories__/CheckboxInput.tsx","webpack:///./src/__stories__/Form.tsx","webpack:///./src/__stories__/FormtronDebugger.tsx","webpack:///./src/__stories__/IntegerInput.tsx","webpack:///./src/__stories__/JsonInput.tsx","webpack:///./src/__stories__/Layouts.tsx","webpack:///./src/__stories__/MarkdownInput.tsx","webpack:///./src/__stories__/Messages.tsx","webpack:///./src/__stories__/MultiselectInput.tsx","webpack:///./src/__stories__/ObjectInput.tsx","webpack:///./src/__stories__/SelectInput.tsx","webpack:///./src/__stories__/StringInput.tsx","webpack:///./src/__stories__/ToggleInput.tsx","webpack:///./src/__stories__/autocompletionSources.ts","webpack:///./src/__stories__/customWidgets.tsx","webpack:///./src/__stories__/decorators.tsx","webpack:///./src/__stories__/index.ts","webpack:///./src/__stories__/stories.tsx","webpack:///./src/applyOps.ts","webpack:///./src/components/ArrayInput.tsx","webpack:///./src/components/AutocompletionContext.ts","webpack:///./src/components/CheckboxInput.tsx","webpack:///./src/components/DiagnosticMessagesContext.ts","webpack:///./src/components/FieldSet.tsx","webpack:///./src/components/Form.tsx","webpack:///./src/components/IconButton.tsx","webpack:///./src/components/IntegerInput.tsx","webpack:///./src/components/JsonInput.tsx","webpack:///./src/components/Label.tsx","webpack:///./src/components/MarkdownInput.tsx","webpack:///./src/components/Messages.tsx","webpack:///./src/components/ObjectInput.tsx","webpack:///./src/components/SelectInput.tsx","webpack:///./src/components/StringInput.tsx","webpack:///./src/components/ToggleInput.tsx","webpack:///./src/components/evaluate.ts","webpack:///./src/components/hooks/index.ts","webpack:///./src/components/hooks/useDiagnostics.ts","webpack:///./src/components/hooks/useTheme.ts","webpack:///./src/components/index.ts","webpack:///./src/components/utils/DraftValue.tsx","webpack:///./src/components/utils/EasyArray.ts","webpack:///./src/components/utils/EasyObject.ts","webpack:///./src/components/utils/ThrottleValue.tsx","webpack:///./src/components/utils/gridHelpers.ts","webpack:///./src/components/utils/replaceWildcards.ts","webpack:///./src/components/utils/shortName.tsx","webpack:///./src/computeOps.ts","webpack:///./src/computeWarnings.ts","webpack:///./src/deriveFormData.ts","webpack:///./src/index.ts","webpack:///./src/theme.ts"],"sourcesContent":["import '@stoplight/storybook-config/config';\n","import { createThemedModule } from '@stoplight/ui-kit';\n\nconst { useTheme, ThemeProvider, ThemeZone } = createThemedModule();\n\nexport { useTheme, ThemeProvider, ThemeZone };\n\nexport const themes = ['dark', 'light'];\n\nexport const zones = {\n  'formtron': ({ base }) => base === 'dark'\n    ? {\n      canvas: {\n        bg: '#111',\n        fg: '#fff',\n        valid: '#009000',\n        invalid: '#ff253a'\n      },\n    } : {\n      canvas: {\n        bg: '#fff',\n        fg: '#111',\n        valid: '#009000',\n        invalid: '#c6211f'\n      },\n    },\n};\n","import * as React from 'react';\n\nimport { ThemeZone } from '@stoplight/ui-kit';\nimport { DraftValue } from './components/utils/DraftValue';\nimport { computeOps } from './computeOps';\nimport { deriveFormData } from './deriveFormData';\nimport { IFormtron } from './types';\n\nexport const Formtron: React.FunctionComponent<IFormtron> = ({\n  value,\n  themeName = 'formtron',\n  schema,\n  selection,\n  onChange,\n  fieldComponents,\n  onInternalChange,\n  disabled = false,\n  layout,\n  resolver,\n}) => (\n  <ThemeZone name={themeName}>\n    <DraftValue\n      value={deriveFormData(schema, value, selection, resolver)}\n      onChange={v => {\n        const ops = computeOps(schema, value, selection, v, resolver);\n        onChange(ops);\n        if (onInternalChange) onInternalChange(v);\n      }}\n    >\n      {({ value, onChange }) => {\n        const Widget = fieldComponents[schema.type];\n        return (\n          <Widget\n            value={value}\n            schema={schema}\n            onChange={onChange}\n            path={selection.split('.')}\n            fieldComponents={fieldComponents}\n            disabled={disabled}\n            layout={layout}\n          />\n        );\n      }}\n    </DraftValue>\n  </ThemeZone>\n);\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit/Box';\nimport { fieldComponents } from '../components';\nimport { ArrayInput } from '../components/ArrayInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('ArrayInput', () => {\n    return (\n      <Box width=\"300px\">\n        <ArrayInput\n          value={[42, 23, 97]}\n          path={[]}\n          schema={{\n            type: 'array',\n            title: 'Array',\n            items: {\n              type: 'integer',\n              title: 'Number',\n            },\n          }}\n          onChange={action('onChange')}\n          fieldComponents={fieldComponents}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit/Box';\nimport { CheckboxInput } from '../components/CheckboxInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('CheckboxInput', () => {\n    return (\n      <Box width=\"300px\">\n        <CheckboxInput\n          value={boolean('value', true)}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            required: boolean('schema.required', false),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit';\nimport { Form } from '../components/Form';\nimport { StringInput } from '../components/StringInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('Form', () => {\n    return (\n      <Box width=\"300px\">\n        <Form\n          value={{\n            key: 'value',\n          }}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            required: boolean('schema.required', false),\n            fields: {\n              key: {\n                type: 'string',\n              },\n            },\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{ string: StringInput }}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import * as React from 'react';\n\n// @ts-ignore\nimport * as ObjectInspector from 'react-object-inspector';\n\nimport { Button } from '@stoplight/ui-kit';\nimport { boolean } from '@storybook/addon-knobs/react';\n\nimport { applyOps, computeWarnings, deriveFormData, Formtron, IOperation } from '../';\nimport { AutocompletionContext, fieldComponents } from '../components';\nimport { Resolver } from '../types';\nimport { autocompletionSources } from './autocompletionSources';\nimport { customWidgets } from './customWidgets';\n\nexport interface IFormtronDebugger {\n  input: any;\n  schema: any;\n  selection: string;\n}\nexport interface IFormtronDebuggerState {\n  initialForm: any;\n  selection: string;\n  form: any;\n  ops: IOperation[];\n  data: any;\n  previewOutput: any;\n}\n\nconst resolver: Resolver = path => (path.join('.').startsWith('magic.portal') ? 'MAGIC' : undefined);\n\nexport class FormtronDebugger extends React.Component<IFormtronDebugger, IFormtronDebuggerState> {\n  public constructor(props: IFormtronDebugger) {\n    super(props);\n    const { input, schema, selection } = props;\n    const initialForm = deriveFormData(schema, input, selection);\n    const initialOutput = applyOps(input, []);\n    this.state = {\n      initialForm,\n      selection,\n      form: initialForm,\n      ops: [],\n      data: input,\n      previewOutput: initialOutput,\n    };\n  }\n  public render() {\n    return (\n      <AutocompletionContext.Provider value={autocompletionSources}>\n        <div className=\"App\">\n          <div style={{ display: 'grid', gridTemplateColumns: '1fr 2fr 1fr' }}>\n            <section\n              style={{\n                gridArea: '1 / 1 / 2 / 2',\n                border: '1px solid black',\n                borderRadius: 5,\n              }}\n            >\n              <legend>Input</legend>\n              <fieldset>\n                <legend>Source Data</legend>\n                <label>Selection Path: {this.state.selection}</label>\n                <ObjectInspector\n                  data={this.state.data}\n                  name=\"data\"\n                  initialExpandedPaths={[\n                    'root',\n                    'root.info',\n                    'root.info.*',\n                    'root.schemes',\n                    'root.paths',\n                    'root.paths./todos',\n                    'root.paths./todos.put',\n                    'root.paths./todos.put.*',\n                    'root.200',\n                    'root.200.*',\n                  ]}\n                />\n              </fieldset>\n              <fieldset>\n                <legend>Form Schema</legend>\n                <ObjectInspector data={this.props.schema} name=\"schema\" initialExpandedPaths={['root', 'root.*']} />\n              </fieldset>\n            </section>\n            <section\n              style={{\n                gridArea: '1 / 2/ 2 / 3',\n                border: '1px solid black',\n                borderRadius: 5,\n              }}\n            >\n              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr' }}>\n                <fieldset>\n                  <legend>Form Data In</legend>\n                  <ObjectInspector data={this.state.initialForm} name=\"form\" initialExpandedPaths={[]} />\n                </fieldset>\n                <fieldset>\n                  <legend>Form Data Out</legend>\n                  <ObjectInspector data={this.state.form} name=\"form\" initialExpandedPaths={[]} />\n                </fieldset>\n              </div>\n              <hr style={{ borderTop: '1px dashed black' }} />\n              <Formtron\n                fieldComponents={{ ...fieldComponents, ...customWidgets }}\n                value={this.state.data}\n                schema={this.props.schema}\n                selection={this.state.selection}\n                onChange={ops => {\n                  const previewOutput = applyOps(this.state.data, ops);\n                  this.setState(state => ({ ...state, ops, previewOutput }));\n                }}\n                onInternalChange={(form: any) => {\n                  this.setState(state => ({ ...state, form }));\n                }}\n                disabled={boolean('disabled', false)}\n                layout=\"default\"\n                resolver={resolver}\n              />\n              <Button\n                type=\"button\"\n                onClick={() => {\n                  const warnings = computeWarnings(this.state.data, this.state.ops);\n                  if (warnings.length > 0) {\n                    for (const warning of warnings) {\n                      const parts = warning.op.path.split('.');\n                      if (parts.length === 3) {\n                        const res = window.confirm(\n                          `There is already a \"${parts[2]}\" response defined on \"${parts[1]}\", overwrite it?`\n                        );\n                        if (!res) return;\n                      } else if (parts.length === 2) {\n                        const res = window.confirm(`There is already a \"${parts[1]}\" route defined, overwrite it?`);\n                        if (!res) return;\n                      }\n                    }\n                  }\n                  const data = applyOps(this.state.data, this.state.ops);\n                  const selectOp = this.state.ops.find(x => x.op === 'select');\n                  const selection = selectOp ? selectOp.path : this.state.selection;\n                  this.setState(state => ({\n                    ...state,\n                    ops: [],\n                    data,\n                    selection,\n                  }));\n                }}\n              >\n                Apply\n              </Button>\n            </section>\n            <section\n              style={{\n                gridArea: '1 / 3 / 2 / 4',\n                border: '1px solid black',\n                borderRadius: 5,\n              }}\n            >\n              <legend>Output</legend>\n              <fieldset>\n                <legend>Result</legend>\n                <ObjectInspector\n                  data={this.state.ops}\n                  name=\"ops\"\n                  initialExpandedPaths={['root', 'root.0', 'root.1', 'root.2', 'root.3']}\n                />\n                <ObjectInspector\n                  data={this.state.previewOutput}\n                  name=\"output\"\n                  initialExpandedPaths={[\n                    'root',\n                    'root.info',\n                    'root.info.*',\n                    'root.schemes',\n                    'root.paths',\n                    'root.paths.*',\n                    'root.paths.*.*',\n                    'root.paths.*.*.*',\n                    'root.200',\n                    'root.200.*',\n                  ]}\n                />\n              </fieldset>\n            </section>\n          </div>\n        </div>\n      </AutocompletionContext.Provider>\n    );\n  }\n}\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, number, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit';\nimport { IntegerInput } from '../components/IntegerInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('IntegerInput', () => {\n    return (\n      <Box width=\"300px\">\n        <IntegerInput\n          value={number('value', 42)}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            required: boolean('schema.required', false),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, object, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit';\nimport { JsonInput } from '../components/JsonInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('JsonInput', () => {\n    return (\n      <Box width=\"300px\">\n        <JsonInput\n          value={object('value', {\n            _id: '5c1ae511f09121c5887e5a93',\n            index: 0,\n            guid: 'f5c7f172-8e61-4a92-b407-1d76f5dfa792',\n            isActive: true,\n            balance: '$3,944.87',\n            picture: 'http://placehold.it/32x32',\n            age: 39,\n            eyeColor: 'green',\n            name: {\n              first: 'Weeks',\n              last: 'Barton',\n            },\n          })}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            required: boolean('schema.required', false),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { select } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit';\nimport { Formtron } from '..';\nimport { fieldComponents } from '../components';\nimport { Theme, Tooltips } from './decorators';\n\nconst data = require('./examples/layouts/data.json');\nconst schema = require('./examples/layouts/schema.json');\n\nconst dataNested = require('./examples/nested-layouts/data.json');\nconst schemaNested = require('./examples/nested-layouts/schema.json');\n\nstoriesOf('Layouts', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('examples', () => {\n    return (\n      <Box width=\"500px\">\n        <Formtron\n          fieldComponents={fieldComponents}\n          value={data}\n          schema={schema}\n          selection=\".\"\n          onChange={action('onChange')}\n          layout={select('layout', ['', '2-col', '3-col', 'hide-some', 'wild'], '')}\n        />\n      </Box>\n    );\n  })\n  .add('nested layouts', () => {\n    return (\n      <Box width=\"500px\">\n        <Formtron\n          fieldComponents={fieldComponents}\n          value={dataNested}\n          schema={schemaNested}\n          selection=\".\"\n          onChange={action('onChange')}\n          layout={select('layout', ['2-col', '4-col'], '2-col')}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit/Box';\nimport { MarkdownInput } from '../components/MarkdownInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('MarkdownInput', () => {\n    return (\n      <Box width=\"500px\">\n        <MarkdownInput\n          value={text(\n            'value',\n            `# What is Lorem Ipsum?\nLorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book. It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.\n\n# Why do we use it?\nIt is a long established fact that a reader will be distracted by the readable content of a page when looking at its layout. The point of using Lorem Ipsum is that it has a more-or-less normal distribution of letters, as opposed to using 'Content here, content here', making it look like readable English. Many desktop publishing packages and web page editors now use Lorem Ipsum as their default model text, and a search for 'lorem ipsum' will uncover many web sites still in their infancy. Various versions have evolved over the years, sometimes by accident, sometimes on purpose (injected humour and the like).`\n          )}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            required: boolean('schema.required', false),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { withKnobs } from '@storybook/addon-knobs';\n\nimport { Flex } from '@stoplight/ui-kit';\nimport { IntegerInput } from '../components/IntegerInput';\nimport { Messages } from '../components/Messages';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('Messages', () => {\n    return (\n      <Flex flexDirection=\"column\" width=\"300px\" m={11}>\n        <Messages path={[]}>\n          <IntegerInput\n            value={42}\n            path={[]}\n            schema={{\n              title: 'Title',\n              required: false,\n            }}\n            onChange={() => void 0}\n            fieldComponents={{}}\n            disabled={false}\n          />\n        </Messages>\n\n        <Messages path={[]}>\n          <IntegerInput\n            value={42}\n            path={[]}\n            schema={{\n              title: 'Title',\n              required: false,\n            }}\n            onChange={() => void 0}\n            fieldComponents={{}}\n            disabled={false}\n          />\n        </Messages>\n      </Flex>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { array, boolean, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit';\nimport { MultiselectInput } from '../components/SelectInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('MultiselectInput', () => {\n    const options = ['choice a', 'choice b', 'choice c'];\n    return (\n      <Box width=\"300px\">\n        <MultiselectInput\n          value={array('value', ['choice a'])}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            options,\n            required: boolean('schema.required', false),\n            strict: boolean('schema.strict', false),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit';\nimport { fieldComponents } from '../components';\nimport { ObjectInput } from '../components/ObjectInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('ObjectInput', () => {\n    return (\n      <Box width=\"300px\">\n        <ObjectInput\n          value={{ first: 42, second: 23, third: 97 }}\n          path={[]}\n          schema={{\n            type: 'object',\n            title: 'Object',\n            keys: {\n              type: 'string',\n              title: 'Name',\n            },\n            values: {\n              type: 'integer',\n              title: 'Number',\n            },\n          }}\n          onChange={action('onChange')}\n          fieldComponents={fieldComponents}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, select, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit/Box';\nimport { SelectInput } from '../components/SelectInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('SelectInput', () => {\n    const options = ['choice a', 'choice b', 'choice c'];\n    return (\n      <Box width=\"300px\">\n        <SelectInput\n          value={select('value', options, 'choice a')}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            options,\n            required: boolean('schema.required', false),\n            strict: boolean('schema.strict', false),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit/Box';\nimport { StringInput } from '../components/StringInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('StringInput', () => {\n    return (\n      <Box width=\"300px\" m={11}>\n        <StringInput\n          value={text('value', 'some text')}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            required: boolean('schema.required', false),\n            minLength: text('schema.minLength', null),\n            maxLength: text('schema.maxLength', null),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { action } from '@storybook/addon-actions';\nimport { withKnobs } from '@storybook/addon-knobs';\nimport { boolean, text } from '@storybook/addon-knobs/react';\n\nimport { Box } from '@stoplight/ui-kit/Box';\nimport { ToggleInput } from '../components/ToggleInput';\nimport { Theme, Tooltips } from './decorators';\n\nstoriesOf('Inputs', module)\n  .addDecorator(withKnobs)\n  .addDecorator(Theme)\n  .addDecorator(Tooltips)\n  .add('ToggleInput', () => {\n    return (\n      <Box width=\"300px\">\n        <ToggleInput\n          value={boolean('value', true)}\n          path={[]}\n          schema={{\n            title: text('schema.title', 'Title'),\n            required: boolean('schema.required', false),\n          }}\n          onChange={action('onChange')}\n          fieldComponents={{}}\n          disabled={boolean('disabled', false)}\n        />\n      </Box>\n    );\n  });\n","import { IAutocompletionProvider, IAutocompletionSources } from '../components';\n\n// This emulates the async-ness if (say) looking up these values from\n// a remote HTTP API.\n\n// I love this guy.\nasync function sleep(ms: number) {\n  return new Promise((resolve, reject) => setTimeout(resolve, ms));\n}\n\nfunction genericAsyncResults(defaults: string[]): IAutocompletionProvider {\n  return async (inputValue: string) => {\n    await sleep(1000);\n    if (!inputValue) {\n      return [\n        {\n          value: null,\n          label: 'Showing first 2 results. Enter search keyword for more.',\n        },\n        ...defaults.map(v => ({ value: v, label: v })),\n      ];\n    } else {\n      return [\n        {\n          value: inputValue,\n          label: inputValue,\n        },\n        {\n          value: `alt_${inputValue}`,\n          label: `alt_${inputValue}`,\n        },\n        {\n          value: `${inputValue}-v2`,\n          label: `${inputValue}-v2`,\n        },\n        {\n          value: `${inputValue}-v3`,\n          label: `${inputValue}-v3`,\n        },\n      ];\n    }\n  };\n}\n\nexport const autocompletionSources: IAutocompletionSources = {\n  tags: genericAsyncResults(['Todos', 'Admin']),\n  models: genericAsyncResults(['TodoItem', 'TodoStatus']),\n};\n","import * as React from 'react';\n\nimport { Button } from '@stoplight/ui-kit';\n\nimport { IFormtronControl } from '../types';\n\nexport const customWidgets = {\n  randomNumber: (props: IFormtronControl) => (\n    <Button\n      type=\"button\"\n      ml={7}\n      fontSize={4}\n      disabled={props.disabled}\n      onClick={() => props.onChange(String(Math.floor(Math.random() * 500)))}\n    >\n      🎲\n    </Button>\n  ),\n  randomOption: (props: IFormtronControl) => (\n    <Button\n      ml={7}\n      fontSize={4}\n      type=\"button\"\n      disabled={props.disabled}\n      onClick={() => props.onChange(props.schema.options[Math.floor(Math.random() * props.schema.options.length)])}\n    >\n      🎲\n    </Button>\n  ),\n  addMoreAwesomeness: (props: IFormtronControl) => (\n    <Button\n      title=\"Add more awesomeness\"\n      ml={7}\n      fontSize={4}\n      type=\"button\"\n      disabled={props.disabled}\n      onClick={() => props.onChange([...props.value, 'awesome'])}\n    >\n      🔥\n    </Button>\n  ),\n};\n","import * as React from 'react';\n\nimport { boolean, select, text } from '@storybook/addon-knobs/react';\n\nimport { ThemeZone } from '../theme';\n\nimport { DiagnosticMessagesContext, IDiagnosticMessagesProvider } from '../components/DiagnosticMessagesContext';\n\nexport const Tooltips = (storyFn: Function) => {\n  const getMessages: IDiagnosticMessagesProvider = path => {\n    const summary = text('message', '');\n    if (summary === '') return [];\n    if (path.length > 0) return [];\n    return [\n      {\n        message: text('message', ''),\n        // Will wanted it to be less TypeScript-ish hence numbers are listed\n        severity: select('severity', [0, 1, 2, 3], 1),\n      },\n    ];\n  };\n  return <DiagnosticMessagesContext.Provider value={getMessages}>{storyFn()}</DiagnosticMessagesContext.Provider>;\n};\n\nexport const PathTooltips = (storyFn: Function) => {\n  const getMessages: IDiagnosticMessagesProvider = path => {\n    return boolean('show path tooltips', false)\n      ? [\n          {\n            message: path.join(' > '),\n            // Will wanted it to be less TypeScript-ish hence numbers are listed\n            severity: select('severity', [0, 1, 2, 3], 1),\n          },\n        ]\n      : [];\n  };\n  return <DiagnosticMessagesContext.Provider value={getMessages}>{storyFn()}</DiagnosticMessagesContext.Provider>;\n};\n\nexport const Theme = (storyFn: Function) => <ThemeZone name=\"formtron\">{storyFn()}</ThemeZone>;\n","// NOTE: The ordering of these imports determines the ordering in Storybook\nimport './ArrayInput';\nimport './CheckboxInput';\nimport './Form';\nimport './IntegerInput';\nimport './JsonInput';\nimport './Layouts';\nimport './MarkdownInput';\nimport './Messages';\nimport './MultiselectInput';\nimport './ObjectInput';\nimport './SelectInput';\nimport './stories';\nimport './StringInput';\nimport './ToggleInput';\n","import { storiesOf } from '@storybook/react';\nimport * as React from 'react';\n\nimport { withKnobs } from '@storybook/addon-knobs';\n\nimport { PathTooltips } from './decorators';\n\nimport { FormtronDebugger } from './FormtronDebugger';\n\nconst simpleData = require('../__tests__/examples/simple/data.json');\nconst simpleSchema = require('../__tests__/examples/simple/schema.json');\n\nconst variousData = require('../__tests__/examples/various-types/data.json');\nconst variousSchema = require('../__tests__/examples/various-types/schema.json');\n\nconst wildcardData = require('../__tests__/examples/wildcards/data.json');\nconst wildcardSchema = require('../__tests__/examples/wildcards/schema.json');\n\nconst complexData = require('../__tests__/examples/complex/data.json');\nconst complexSchema = require('../__tests__/examples/complex/schema.json');\n\nconst dependentData = require('../__tests__/examples/dependent-variables/data.json');\nconst dependendSchema1 = require('../__tests__/examples/dependent-variables/schemaA.json');\nconst dependentSchema2 = require('../__tests__/examples/dependent-variables/schemaB.json');\n\nconst rootData = require('../__tests__/examples/root/data.json');\nconst rootSchema = require('../__tests__/examples/root/schema.json');\n\nconst customWidgetData = require('./examples/custom-widget/data.json');\nconst customWidgetSchema = require('./examples/custom-widget/schema.json');\n\nconst arrayData = require('./examples/array/data.json');\nconst arraySchema = require('./examples/array/schema.json');\n\nconst objectData = require('./examples/object/data.json');\nconst objectSchema = require('./examples/object/schema.json');\n\nconst showData = require('./examples/show/data.json');\nconst showSchema = require('./examples/show/schema.json');\n\nconst enableData = require('./examples/enable/data.json');\nconst enableSchema = require('./examples/enable/schema.json');\n\nconst evalOptionsData = require('./examples/evalOptions/data.json');\nconst evalOptionsSchema = require('./examples/evalOptions/schema.json');\n\nconst resolverData = require('./examples/resolver/data.json');\nconst resolverSchema = require('./examples/resolver/schema.json');\n\n// We need to load some Icons into the IconLibrary!\nimport { faCheck } from '@fortawesome/free-solid-svg-icons';\nimport { IconLibrary } from '@stoplight/ui-kit';\n// @ts-ignore\nIconLibrary.add(faCheck);\n\nstoriesOf('formtron', module)\n  .addDecorator(withKnobs)\n  .addDecorator(PathTooltips)\n  .add('simple', () => {\n    return <FormtronDebugger input={simpleData} schema={simpleSchema} selection={simpleData._selection} />;\n  })\n  .add('various types', () => {\n    return <FormtronDebugger input={variousData} schema={variousSchema} selection={variousData._selection} />;\n  })\n  .add('wildcards', () => {\n    return <FormtronDebugger input={wildcardData} schema={wildcardSchema} selection={wildcardData._selection} />;\n  })\n  .add('complex', () => {\n    return <FormtronDebugger input={complexData} schema={complexSchema} selection={complexData._selection} />;\n  })\n  .add('dependent variables 1', () => {\n    return <FormtronDebugger input={dependentData} schema={dependendSchema1} selection={dependentData._selection} />;\n  })\n  .add('dependent variables 2', () => {\n    return <FormtronDebugger input={dependentData} schema={dependentSchema2} selection={dependentData._selection} />;\n  })\n  .add('custom widgets', () => {\n    return (\n      <FormtronDebugger input={customWidgetData} schema={customWidgetSchema} selection={customWidgetData._selection} />\n    );\n  })\n  .add('array', () => {\n    return <FormtronDebugger input={arrayData} schema={arraySchema} selection={arrayData._selection} />;\n  })\n  .add('object', () => {\n    return <FormtronDebugger input={objectData} schema={objectSchema} selection={objectData._selection} />;\n  })\n  .add('show', () => {\n    return <FormtronDebugger input={showData} schema={showSchema} selection={showData._selection} />;\n  })\n  .add('enable', () => {\n    return <FormtronDebugger input={enableData} schema={enableSchema} selection={enableData._selection} />;\n  })\n  .add('evalOptions', () => {\n    return (\n      <FormtronDebugger input={evalOptionsData} schema={evalOptionsSchema} selection={evalOptionsData._selection} />\n    );\n  })\n  .add('root data node', () => {\n    return <FormtronDebugger input={rootData} schema={rootSchema} selection=\"title\" />;\n  })\n  .add('custom resolver', () => {\n    return <FormtronDebugger input={resolverData} schema={resolverSchema} selection=\"title\" />;\n  });\n","import produce from 'immer';\nimport get = require('lodash/get');\nimport set = require('lodash/set');\nimport unset = require('lodash/unset');\n\nimport { IOperation } from './types';\n\nconst parentPath = (path: string) => path.slice(0, path.lastIndexOf('.'));\nconst childPath = (path: string) => path.slice(path.lastIndexOf('.') + 1);\n\nexport const applyOps = (_data: any, ops: IOperation[]) =>\n  produce(_data, data => {\n    // Apply operations\n    for (const op of ops) {\n      switch (op.op) {\n        case 'add': {\n          // There's one edge case where path = \"\"\n          if (op.path === '') {\n            for (const p in data) {\n              delete data[p];\n            }\n            Object.assign(data, op.value);\n          } else {\n            set(data, op.path, op.value);\n          }\n          break;\n        }\n        case 'move': {\n          if (parentPath(op.from) === parentPath(op.path)) {\n            // Detect and perform a rename in place.\n            const o = {};\n            const parent = parentPath(op.from);\n            const childFrom = childPath(op.from);\n            const childTo = childPath(op.path);\n            for (const [key, value] of Object.entries(get(data, parent))) {\n              if (key === childFrom) {\n                o[childTo] = value;\n              } else {\n                o[key] = value;\n              }\n            }\n            set(data, parent, o);\n          } else {\n            const node = get(data, op.from);\n            set(data, op.path, node);\n            unset(data, op.from);\n          }\n          break;\n        }\n      }\n    }\n  });\n","import * as React from 'react';\n\nimport { faPlus, faTrash } from '@fortawesome/free-solid-svg-icons';\n\nimport { Box, Button, Flex, Icon } from '@stoplight/ui-kit';\n\nimport { IFormtronControl } from '..';\n\nimport { FieldSet } from './FieldSet';\nimport { useDiagnostics } from './hooks';\nimport { IconButton } from './IconButton';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\nimport { EasyArray } from './utils/EasyArray';\n\nexport const ArrayInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value = [],\n  schema,\n  onChange,\n  fieldComponents,\n  disabled = false,\n  path,\n  layout,\n}) => {\n  const { variant } = useDiagnostics(path);\n  const easyArray = new EasyArray(value, schema.default);\n  const Widget = fieldComponents[schema.items.type];\n\n  return (\n    <Messages path={path}>\n      <FieldSet position=\"relative\" variant={variant} legend={schema.title}>\n        {easyArray.items.length === 0 ? (\n          <Button\n            fontWeight={800}\n            fontSize=\"11px\"\n            my={11}\n            mx={7}\n            color=\"rgb(118, 130, 143)\"\n            disabled={disabled}\n            display=\"inline-block\"\n            borderColor=\"transparent\"\n            backgroundColor=\"transparent\"\n            onClick={() => onChange(easyArray.append())}\n          >\n            <Icon mr={7} icon={faPlus} /> Add Item\n          </Button>\n        ) : (\n          easyArray.items.map((val: any, index: number) => {\n            return (\n              <Flex my={11} mx={7} key={`${index}-${value.length}`}>\n                <Box flex={1} mr=\"10px\">\n                  <Widget\n                    id={(id && `${id}-${index}`) || undefined}\n                    value={val}\n                    schema={schema.items}\n                    path={[...path, String(index)]}\n                    fieldComponents={fieldComponents}\n                    onChange={_val => onChange(easyArray.update(index, _val))}\n                    disabled={disabled}\n                    layout={layout}\n                  />\n                </Box>\n\n                <Flex flexDirection=\"column\" alignItems=\"center\" mx=\"10px\">\n                  <Label disabled={disabled}>Add</Label>\n\n                  <Flex flex={1} width=\"100%\" justifyContent=\"center\" alignItems=\"center\">\n                    <IconButton\n                      icon={faPlus}\n                      onClick={() => onChange(easyArray.insert(index + 1))}\n                      disabled={disabled}\n                    />\n                  </Flex>\n                </Flex>\n\n                <Flex flexDirection=\"column\" alignItems=\"center\" ml=\"10px\">\n                  <Label disabled={disabled}>Remove</Label>\n\n                  <Flex flex={1} width=\"100%\" justifyContent=\"center\" alignItems=\"center\" disabled={disabled}>\n                    <IconButton icon={faTrash} onClick={() => onChange(easyArray.remove(index))} disabled={disabled} />\n                  </Flex>\n                </Flex>\n              </Flex>\n            );\n          })\n        )}\n      </FieldSet>\n    </Messages>\n  );\n};\n","import { Dictionary } from '@stoplight/types';\nimport * as React from 'react';\n\nexport interface IAutocompletionOption {\n  value: any;\n  label: string;\n}\nexport type IAutocompletionProvider = (inputValue: string) => Promise<IAutocompletionOption[]>;\n\nexport type IAutocompletionSources = Dictionary<IAutocompletionProvider>;\n\nexport const AutocompletionContext: React.Context<IAutocompletionSources> = React.createContext({});\n","import { Box, Checkbox, Flex } from '@stoplight/ui-kit';\nimport * as React from 'react';\n\nimport { IFormtronControl } from '..';\n\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\n\nexport const CheckboxInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value,\n  onChange,\n  schema,\n  path,\n  disabled = false,\n}) => {\n  const { variant } = useDiagnostics(path);\n  return (\n    <Flex flexDirection=\"column\" width=\"100%\" height=\"100%\">\n      <Box>\n        <Messages path={path}>\n          <Label htmlFor={id} variant={variant} disabled={disabled}>\n            {schema.title}\n          </Label>\n        </Messages>\n      </Box>\n      <Flex alignItems=\"center\" flex=\"1\">\n        <Checkbox mr=\"auto\" id={id} checked={value} onChange={onChange} variant={variant} disabled={disabled} />\n      </Flex>\n    </Flex>\n  );\n};\n","import { JsonPath } from '@stoplight/types';\nimport * as React from 'react';\nimport { IFormtronDiagnostic } from '../types';\n\nexport type IDiagnosticMessagesProvider = (path: JsonPath) => IFormtronDiagnostic[];\n\nexport const DiagnosticMessagesContext = React.createContext<IDiagnosticMessagesProvider>(() => []);\n","import * as React from 'react';\n\nimport { Box, IBox, Variant } from '@stoplight/ui-kit';\n\nimport { useBorder } from './hooks';\n\ninterface IFieldSet extends IBox<HTMLFieldSetElement> {\n  legend: HTMLElement | string;\n  variant?: Variant;\n}\n\nexport const FieldSet: React.FunctionComponent<IFieldSet> = ({ legend, variant, children, disabled = false }) => {\n  const borderColor = useBorder(variant) || 'currentColor';\n  return (\n    <Box as=\"fieldset\" border={`1px solid ${borderColor}`}>\n      <Box as=\"legend\" color={borderColor}>\n        {legend}\n      </Box>\n      {children}\n    </Box>\n  );\n};\n","import * as React from 'react';\n\nimport { IFormtronControl } from '..';\n\nimport { Box, Flex } from '@stoplight/ui-kit';\nimport { evaluate } from './evaluate';\nimport { FieldSet } from './FieldSet';\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\nimport { parseGridTemplateAreas } from './utils/gridHelpers';\nimport { replaceWildcards } from './utils/replaceWildcards';\nimport { shortName } from './utils/shortName';\n\nexport const Form: React.FunctionComponent<IFormtronControl> = ({\n  value = {},\n  schema,\n  onChange,\n  fieldComponents,\n  path,\n  disabled = false,\n  layout,\n}) => {\n  const { variant } = useDiagnostics(path);\n\n  const { title, description, fields, layouts } = schema;\n\n  const gridAreaToName = {};\n  const shortValue = {};\n  const fallbackRows = [];\n  let contentElems: React.ReactElement | React.ReactElement[] = [];\n\n  for (const fieldName in fields) {\n    if (fields.hasOwnProperty(fieldName)) {\n      const { area } = fields[fieldName];\n      const gridArea = area || shortName(fieldName);\n      gridAreaToName[gridArea] = fieldName;\n      shortValue[gridArea] = value[fieldName];\n      fallbackRows.push([gridArea]);\n    }\n  }\n\n  const grid = layout && layouts && layouts[layout];\n  const rows = grid ? parseGridTemplateAreas(grid) : fallbackRows;\n\n  for (const row of rows) {\n    const cells: React.ReactElement[] = [];\n\n    // preprocess row\n    const flex = {};\n    const cellNames = [];\n    for (const gridArea of row) {\n      if (flex[gridArea]) {\n        flex[gridArea] += 1;\n      } else {\n        flex[gridArea] = 1;\n        cellNames.push(gridArea);\n      }\n    }\n\n    cellNames.forEach((gridArea, index) => {\n      const name = gridAreaToName[gridArea];\n      const formId = `${name}-${index}`;\n\n      const propSchema = schema.fields[name];\n      const { show, evalOptions, enabled, type } = propSchema;\n\n      // if evalutating show is false skip area\n      if (show && !evaluate(show, shortValue, gridArea, true)) {\n        return;\n      }\n\n      if (evalOptions) {\n        propSchema.options = evaluate(evalOptions, shortValue, gridArea, []);\n      }\n\n      const enableField = !enabled || evaluate(enabled, shortValue, gridArea, true);\n\n      const Widget = fieldComponents[type];\n      if (Widget === undefined) {\n        cells.push(<Box flex={flex[gridArea]}>No appropriate widget could be found for type \"{type}\"</Box>);\n      } else {\n        cells.push(\n          <Box\n            key={formId}\n            flex={flex[gridArea]}\n            ml={index === 0 ? 0 : '10px'}\n            mr={index === cellNames.length - 1 ? 0 : '10px'}\n            my=\"12px\"\n          >\n            <Widget\n              id={formId}\n              value={value[name]}\n              schema={propSchema}\n              path={replaceWildcards(name, path)}\n              onChange={(val: any) => {\n                const v = { ...value, [name]: val };\n                onChange(v);\n              }}\n              fieldComponents={fieldComponents}\n              disabled={disabled || !enableField}\n              layout={layout}\n            />\n          </Box>\n        );\n      }\n    });\n\n    if (cells.length > 0) {\n      contentElems.push(<Flex>{cells}</Flex>);\n    }\n  }\n\n  if (title) {\n    contentElems = (\n      <FieldSet legend={title} variant={variant} disabled={disabled}>\n        <Label disabled={disabled}>\n          <i>{description}</i>\n        </Label>\n        {contentElems}\n      </FieldSet>\n    );\n  }\n\n  return <Messages path={path}>{contentElems}</Messages>;\n};\n","import * as React from 'react';\n\nimport { Button, IButton, Icon } from '@stoplight/ui-kit';\n\nimport { IconDefinition } from '@fortawesome/free-solid-svg-icons';\n\ninterface IIconButton extends IButton {\n  disabled?: boolean;\n  onClick?: (event: React.MouseEvent<HTMLElement, MouseEvent>) => void;\n  icon: IconDefinition;\n}\n\nexport const IconButton: React.FunctionComponent<IIconButton> = ({ disabled = false, onClick, icon }) => {\n  return (\n    <Button\n      borderColor=\"transparent\"\n      backgroundColor=\"transparent\"\n      height=\"100%\"\n      fontSize=\"15px\"\n      px={0}\n      py={0}\n      onClick={onClick}\n      disabled={disabled}\n      color=\"rgb(118, 130, 143)\"\n      css={{\n        ':hover': {\n          backgroundColor: 'transparent',\n          color: '#1E2537',\n        },\n        ':active': {\n          backgroundColor: 'transparent',\n          fontSize: '17px',\n        },\n      }}\n    >\n      <Icon icon={icon} />\n    </Button>\n  );\n};\n","import { Box, Flex, Input } from '@stoplight/ui-kit';\nimport * as React from 'react';\n\nimport { IFormtronControl } from '..';\n\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\n\nexport const IntegerInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value,\n  schema,\n  onChange,\n  path,\n  fieldComponents,\n  disabled = false,\n}) => {\n  const { variant } = useDiagnostics(path);\n  const CustomWidget = fieldComponents[schema.custom && schema.custom.widget];\n\n  return (\n    <Box>\n      <Box>\n        <Messages path={path}>\n          <Label htmlFor={id} variant={variant} disabled={disabled}>\n            {schema.title}\n          </Label>\n        </Messages>\n      </Box>\n      <Flex>\n        <Input\n          flex=\"1\"\n          type=\"number\"\n          id={id}\n          step=\"1.0\"\n          value={value}\n          onChange={(e: React.SyntheticEvent<HTMLInputElement>) => onChange(Number(e.currentTarget.value))}\n          variant={variant}\n          disabled={disabled}\n          width=\"100%\"\n        />\n        {CustomWidget && (\n          <CustomWidget\n            value={value}\n            schema={schema}\n            onChange={onChange}\n            path={path}\n            fieldComponents={fieldComponents}\n            disabled={disabled}\n          />\n        )}\n      </Flex>\n    </Box>\n  );\n};\n","import * as React from 'react';\n\nimport { Box, Textarea } from '@stoplight/ui-kit';\n\nimport { IFormtronControl } from '..';\n\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\nimport { DraftValue } from './utils/DraftValue';\n\nexport const JsonInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value,\n  schema,\n  onChange,\n  path,\n  disabled = false,\n}) => {\n  const { variant } = useDiagnostics(path);\n  return (\n    <DraftValue\n      value={JSON.stringify(value, null, 2)}\n      onChange={draft => {\n        try {\n          onChange(JSON.parse(draft));\n        } catch (err) {\n          // do nothing\n        }\n      }}\n    >\n      {({ value, onChange, nonDraftValue }) => {\n        return (\n          <Box>\n            <Box>\n              <Messages path={path}>\n                <Label htmlFor={id} variant={variant} disabled={disabled}>\n                  {schema.title}\n                </Label>\n              </Messages>\n            </Box>\n            <Box>\n              <Textarea\n                flex=\"1\"\n                autosize={true}\n                color={nonDraftValue === value ? undefined : 'red'}\n                id={id}\n                value={value}\n                onChange={(e: React.SyntheticEvent<HTMLTextAreaElement>) => onChange(e.currentTarget.value)}\n                variant={variant}\n                disabled={disabled}\n                width=\"100%\"\n              />\n            </Box>\n          </Box>\n        );\n      }}\n    </DraftValue>\n  );\n};\n","import toUpper = require('lodash/toUpper');\nimport * as React from 'react';\n\nimport { IText, Text, Variant } from '@stoplight/ui-kit';\n\ninterface ILabel extends IText<HTMLLabelElement> {\n  variant?: Variant;\n}\n\nexport const Label: React.FunctionComponent<ILabel> = ({ htmlFor, variant, children, disabled = false }) => {\n  const disabledStyles = disabled\n    ? {\n        opacity: 0.6,\n        cursor: 'not-allowed',\n      }\n    : null;\n  return (\n    <Text\n      fontWeight={800}\n      fontSize=\"11px\"\n      mb=\"6px\"\n      ml=\"2px\"\n      as=\"label\"\n      color=\"rgb(118, 130, 143)\"\n      display=\"block\"\n      htmlFor={htmlFor}\n      css={{ ...disabledStyles }}\n    >\n      {typeof children === 'string' ? toUpper(children) : children}\n    </Text>\n  );\n};\n","import * as React from 'react';\n\nimport { Box, Textarea } from '@stoplight/ui-kit';\n\nimport { IFormtronControl } from '..';\n\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\nimport { ThrottleValue } from './utils/ThrottleValue';\n\nexport const MarkdownInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value,\n  schema,\n  onChange,\n  path,\n  disabled = false,\n}) => {\n  const { variant } = useDiagnostics(path);\n  return (\n    <ThrottleValue ms={1000} value={value} onChange={onChange}>\n      {({ value, onChange }) => (\n        <Box>\n          <Box>\n            <Messages path={path}>\n              <Label htmlFor={id} variant={variant} disabled={disabled}>\n                {schema.title}\n              </Label>\n            </Messages>\n          </Box>\n          <Box>\n            <Textarea\n              width=\"100%\"\n              id={id}\n              autosize={true}\n              value={value}\n              onChange={(e: React.SyntheticEvent<HTMLTextAreaElement>) => onChange(e.currentTarget.value)}\n              variant={variant}\n              disabled={disabled}\n            />\n          </Box>\n        </Box>\n      )}\n    </ThrottleValue>\n  );\n};\n","import * as React from 'react';\n\nimport { JsonPath } from '@stoplight/types';\nimport { Box, Popup } from '@stoplight/ui-kit';\nimport { Tooltip } from '@stoplight/ui-kit/Tooltip';\n\nimport { useDiagnostics } from './hooks';\n\ninterface IMessages {\n  path: JsonPath;\n}\n\nexport const Messages: React.FunctionComponent<IMessages> = ({ path, children }) => {\n  const { messages, variant } = useDiagnostics(path);\n  const message = messages.map(m => m.summary || m.message).join(' | ');\n  const showTooltip = message != null && message !== '';\n  return (\n    <Popup\n      posX=\"left\"\n      posY=\"top\"\n      padding={3}\n      renderContent={() =>\n        showTooltip && (\n          <Tooltip posX=\"left\" variant={variant}>\n            {message}\n          </Tooltip>\n        )\n      }\n      renderTrigger={() => <Box>{children}</Box>}\n    />\n  );\n};\n\nMessages.displayName = 'Messages';\n","import * as React from 'react';\n\nimport { faPlus, faTrash } from '@fortawesome/free-solid-svg-icons';\n\nimport { Box, Button, Flex, Icon } from '@stoplight/ui-kit';\n\nimport { IFormtronControl } from '..';\n\nimport { FieldSet } from './FieldSet';\nimport { useDiagnostics } from './hooks';\nimport { IconButton } from './IconButton';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\nimport { DraftValue } from './utils/DraftValue';\nimport { EasyObject } from './utils/EasyObject';\n\nexport const ObjectInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value = {},\n  schema,\n  onChange,\n  fieldComponents,\n  path,\n  disabled = false,\n  layout,\n}) => {\n  const { variant } = useDiagnostics(path);\n  // Make this thing an array\n  const easyObject = new EasyObject(value, schema.default);\n  const KeyWidget = fieldComponents[schema.keys.type];\n  const ValWidget = fieldComponents[schema.values.type];\n\n  const noConflict = (key: PropertyKey) => !(key in value);\n\n  return (\n    <Messages path={path}>\n      <FieldSet position=\"relative\" variant={variant} legend={schema.title}>\n        {easyObject.items.length === 0 ? (\n          <Button\n            fontWeight={800}\n            fontSize=\"11px\"\n            color=\"rgb(118, 130, 143)\"\n            disabled={disabled}\n            display=\"inline-block\"\n            borderColor=\"transparent\"\n            backgroundColor=\"transparent\"\n            onClick={() => onChange(easyObject.append())}\n          >\n            <Icon mr={7} icon={faPlus} /> Add Item\n          </Button>\n        ) : (\n          easyObject.items.map((entry, index) => {\n            const [key, val] = entry;\n            return (\n              <Flex my={11} mx={7} key={`${index}-${easyObject.items.length}`}>\n                <DraftValue\n                  value={key}\n                  onChange={_key => noConflict(_key) && onChange(easyObject.updateKey(index, _key))}\n                >\n                  {({ value, onChange }) => {\n                    return (\n                      <React.Fragment>\n                        <Box flex={1} mr=\"10px\">\n                          <KeyWidget\n                            id={(id && `${id}-${index}`) || undefined}\n                            value={value}\n                            schema={schema.keys}\n                            path={[...path, key]}\n                            fieldComponents={fieldComponents}\n                            onChange={_key => onChange(_key)}\n                            disabled={disabled}\n                            layout={layout}\n                          />\n                        </Box>\n                      </React.Fragment>\n                    );\n                  }}\n                </DraftValue>\n                <Box flex={1} mx=\"10px\">\n                  <ValWidget\n                    id={(id && `${id}-${index}`) || undefined}\n                    value={val}\n                    schema={schema.values}\n                    onChange={_val => onChange(easyObject.updateVal(index, _val))}\n                    path={[...path, key]}\n                    fieldComponents={fieldComponents}\n                    disabled={disabled}\n                    layout={layout}\n                  />\n                </Box>\n\n                <Flex flexDirection=\"column\" alignItems=\"center\" mx=\"10px\">\n                  <Label disabled={disabled}>Add</Label>\n\n                  <Flex flex={1} width=\"100%\" justifyContent=\"center\" alignItems=\"center\">\n                    <IconButton\n                      icon={faPlus}\n                      onClick={() => onChange(easyObject.insert(index + 1))}\n                      disabled={disabled}\n                    />\n                  </Flex>\n                </Flex>\n\n                <Flex flexDirection=\"column\" alignItems=\"center\" ml=\"10px\">\n                  <Label disabled={disabled}>Remove</Label>\n\n                  <Flex flex={1} width=\"100%\" justifyContent=\"center\" alignItems=\"center\">\n                    <IconButton icon={faTrash} onClick={() => onChange(easyObject.remove(index))} disabled={disabled} />\n                  </Flex>\n                </Flex>\n              </Flex>\n            );\n          })\n        )}\n      </FieldSet>\n    </Messages>\n  );\n};\n","import { Box, Flex } from '@stoplight/ui-kit';\nimport { Select } from '@stoplight/ui-kit/Select';\nimport * as React from 'react';\n\nimport { IFormtronControl } from '..';\n\nimport { AutocompletionContext } from './AutocompletionContext';\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\nimport { DraftValue } from './utils/DraftValue';\n\nexport const SelectInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value,\n  schema,\n  onChange,\n  path,\n  fieldComponents,\n  disabled = false,\n}) => {\n  const { variant } = useDiagnostics(path);\n\n  return (\n    <AutocompletionContext.Consumer>\n      {autocompletionSources => {\n        const CustomWidget = fieldComponents[schema.custom && schema.custom.widget];\n        const loadOptions =\n          schema.custom && schema.custom.source\n            ? autocompletionSources[schema.custom.source]\n            : schema.options\n              ? async () => schema.options.map((o: string) => ({ value: o, label: o }))\n              : async (search: string) => [{ value: search, label: search }];\n        return (\n          <Box>\n            <Box>\n              <Messages path={path}>\n                <Label htmlFor={id} variant={variant} disabled={disabled}>\n                  {schema.title}\n                </Label>\n              </Messages>\n            </Box>\n            <Box>\n              <DraftValue value={value} onChange={onChange}>\n                {({ value, onChange }) => (\n                  <Flex width=\"100%\">\n                    <Box flex=\"1\">\n                      <Select\n                        key={JSON.stringify(schema.options)}\n                        value={{ value, label: value }}\n                        defaultValue={{ value, label: value }}\n                        defaultOptions\n                        loadOptions={loadOptions}\n                        onChange={(value: any) => {\n                          if (value === null) {\n                            onChange(value);\n                          } else {\n                            onChange(value.value);\n                          }\n                        }}\n                        menuPlacement=\"auto\"\n                        clearable={!schema.required}\n                        allowCreate={!schema.strict}\n                        variant={variant}\n                        disabled={disabled}\n                        searchable={false}\n                        {...schema.custom && schema.custom.props}\n                      />\n                    </Box>\n                    {CustomWidget && (\n                      <CustomWidget\n                        value={value}\n                        schema={schema}\n                        path={path}\n                        onChange={onChange}\n                        fieldComponents={fieldComponents}\n                        disabled={disabled}\n                      />\n                    )}\n                  </Flex>\n                )}\n              </DraftValue>\n            </Box>\n          </Box>\n        );\n      }}\n    </AutocompletionContext.Consumer>\n  );\n};\n\nexport const MultiselectInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value = [],\n  schema,\n  onChange,\n  fieldComponents,\n  path,\n  disabled = false,\n}) => {\n  if (!Array.isArray(value)) {\n    throw new Error(`MultiSelect expects it's value prop to be an array but it was of type ${typeof value}`);\n  }\n  const { variant } = useDiagnostics(path);\n\n  return (\n    <AutocompletionContext.Consumer>\n      {autocompletionSources => {\n        const CustomWidget = fieldComponents[schema.custom && schema.custom.widget];\n        const loadOptions =\n          schema.custom && schema.custom.source\n            ? autocompletionSources[schema.custom.source]\n            : schema.options\n              ? async () => schema.options.map((o: string) => ({ value: o, label: o }))\n              : async (search: string) => [{ value: search, label: search }];\n        return (\n          <Box>\n            <Messages path={path}>\n              <Label htmlFor={id} variant={variant} disabled={disabled}>\n                {schema.title}\n              </Label>\n            </Messages>\n            <Flex>\n              <Box flex=\"1\">\n                <Select\n                  key={JSON.stringify(value) + JSON.stringify(schema.options)}\n                  defaultValue={value.map(_value => ({ value: _value, label: _value }))}\n                  isMulti\n                  loadOptions={loadOptions}\n                  defaultOptions\n                  onChange={(values: any) =>\n                    values && Array.isArray(values)\n                      ? onChange(values.map(v => v.value))\n                      : values && onChange(values.value)\n                  }\n                  menuPlacement=\"auto\"\n                  allowCreate={!schema.strict}\n                  variant={variant}\n                  disabled={disabled}\n                  clearable={false}\n                  searchable={false}\n                  {...schema.custom && schema.custom.props}\n                />\n              </Box>\n              {CustomWidget && (\n                <CustomWidget\n                  value={value}\n                  schema={schema}\n                  path={path}\n                  onChange={onChange}\n                  fieldComponents={fieldComponents}\n                  disabled={disabled}\n                />\n              )}\n            </Flex>\n          </Box>\n        );\n      }}\n    </AutocompletionContext.Consumer>\n  );\n};\n","import { Box, Input } from '@stoplight/ui-kit';\nimport * as React from 'react';\n\nimport { IFormtronControl } from '..';\n\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\n\nexport const StringInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value = '',\n  schema,\n  onChange,\n  path,\n  disabled = false,\n}) => {\n  const { variant } = useDiagnostics(path);\n\n  return (\n    <Box>\n      <Box>\n        <Messages path={path}>\n          <Label htmlFor={id} variant={variant} disabled={disabled}>\n            {schema.title}\n          </Label>\n        </Messages>\n      </Box>\n      <Box>\n        <Input\n          type=\"text\"\n          id={id}\n          value={value}\n          onChange={(e: React.SyntheticEvent<HTMLInputElement>) => onChange(e.currentTarget.value)}\n          minLength={schema.minLength}\n          maxLength={schema.maxLength}\n          required={schema.required}\n          flex=\"1\"\n          variant={variant}\n          disabled={disabled}\n          width=\"100%\"\n        />\n      </Box>\n    </Box>\n  );\n};\n","import { Box, Flex, Toggle } from '@stoplight/ui-kit';\nimport * as React from 'react';\n\nimport { IFormtronControl } from '..';\n\nimport { useDiagnostics } from './hooks';\nimport { Label } from './Label';\nimport { Messages } from './Messages';\n\nexport const ToggleInput: React.FunctionComponent<IFormtronControl> = ({\n  id,\n  value,\n  onChange,\n  schema,\n  path,\n  disabled = false,\n}) => {\n  const { variant } = useDiagnostics(path);\n  return (\n    <Flex flexDirection=\"column\" width=\"100%\" height=\"100%\">\n      <Box>\n        <Messages path={path}>\n          <Label htmlFor={id} variant={variant} disabled={disabled}>\n            {schema.title}\n          </Label>\n        </Messages>\n      </Box>\n      <Flex alignItems=\"center\" flex=\"1\">\n        <Toggle mr=\"auto\" id={id} checked={value} onChange={onChange} variant={variant} disabled={disabled} />\n      </Flex>\n    </Flex>\n  );\n};\n","const expr = require('expression-eval');\nconst memoize = require('lodash/memoize');\n\n// Compile expression or return cached compiled expression\nconst compile = memoize(expr.compile);\n\nexport function evaluate(str: string, context: any, currentProp: string, fallbackValue: any, debug: boolean = false) {\n  // Transform `paths.*.*.responses.*.foo` into `foo`\n  const _context = {};\n  for (const prop in context) {\n    // Only consider properties ABOVE the current property in the schema\n    // (This enforces a top-to-bottom data dependency which is just nice.)\n    if (prop === currentProp) break;\n    _context[prop] = context[prop];\n  }\n  // Evaluate expression\n  try {\n    return compile(str)(_context);\n  } catch (err) {\n    if (debug) {\n      console.log(err, str, _context);\n    }\n    return fallbackValue;\n  }\n}\n","export * from './useDiagnostics';\nexport * from './useTheme';\n","import { DiagnosticSeverity, Dictionary, JsonPath } from '@stoplight/types';\nimport { Variant } from '@stoplight/ui-kit/types';\nimport { useContext } from 'react';\n\nimport { IFormtronDiagnostic } from '../../types';\nimport { DiagnosticMessagesContext, IDiagnosticMessagesProvider } from '../DiagnosticMessagesContext';\n\nconst variantsMap: Dictionary<Variant, DiagnosticSeverity> = {\n  [DiagnosticSeverity.Hint]: Variant.Default,\n  [DiagnosticSeverity.Information]: Variant.Default,\n  [DiagnosticSeverity.Error]: Variant.Invalid,\n  [DiagnosticSeverity.Warning]: Variant.Warning,\n};\n\nexport type UseDiagnostics = (\n  path: JsonPath\n) => {\n  variant: Variant;\n  messages: IFormtronDiagnostic[];\n};\n\nexport const useDiagnostics: UseDiagnostics = path => {\n  const getMessages = useContext<IDiagnosticMessagesProvider>(DiagnosticMessagesContext);\n  const messages = getMessages(path);\n  const severity = Math.min(...messages.map(({ severity }) => severity));\n\n  return { variant: variantsMap[severity], messages };\n};\n","const capitalize = require('lodash/capitalize');\nimport { Variant } from '@stoplight/ui-kit';\n\nimport { useTheme } from '../../theme';\n\nconst useProp = (prop: string) => (variant?: Variant) => {\n  const theme = useTheme();\n  const _prop = variant ? variant + capitalize(prop) : prop;\n  if (!theme.input || !theme.input[_prop]) return;\n  return theme.input[_prop];\n};\n\nexport const useBorder = useProp('border');\n\nexport const useFg = useProp('fg');\n\nexport const useBg = useProp('bg');\n","import { ArrayInput } from './ArrayInput';\nimport { CheckboxInput } from './CheckboxInput';\nimport { Form } from './Form';\nimport { IntegerInput } from './IntegerInput';\nimport { JsonInput } from './JsonInput';\nimport { MarkdownInput } from './MarkdownInput';\nimport { ObjectInput } from './ObjectInput';\nimport { MultiselectInput, SelectInput } from './SelectInput';\nimport { StringInput } from './StringInput';\nimport { ToggleInput } from './ToggleInput';\n\nexport const fieldComponents = {\n  array: ArrayInput,\n  object: ObjectInput,\n  checkbox: CheckboxInput,\n  form: Form,\n  integer: IntegerInput,\n  json: JsonInput,\n  markdown: MarkdownInput,\n  multiselect: MultiselectInput,\n  select: SelectInput,\n  string: StringInput,\n  toggle: ToggleInput,\n};\n\nexport * from './AutocompletionContext';\nexport * from './DiagnosticMessagesContext';\n","import * as React from 'react';\n\nexport interface IInputWidget {\n  value: any;\n  onChange: (value: any) => void;\n}\n\nexport interface IDraftValueState {\n  draft: any;\n  value: any;\n}\n\nexport interface IDraftValue extends IInputWidget {\n  children: React.FunctionComponent<IInputWidget & { nonDraftValue: any }>;\n}\n\nexport class DraftValue extends React.Component<IDraftValue, IDraftValueState> {\n  public state = {\n    draft: this.props.value,\n    value: this.props.value,\n  };\n\n  public static getDerivedStateFromProps(props: IInputWidget, state: IDraftValueState) {\n    if (props.value !== state.value) {\n      return {\n        value: props.value,\n        draft: props.value,\n      };\n    }\n    return null;\n  }\n\n  private onChange = (value: any) => {\n    this.setState({ draft: value, value: this.state.value });\n    this.props.onChange(value);\n  };\n\n  public render() {\n    return this.props.children({\n      value: this.state.draft,\n      onChange: this.onChange,\n      nonDraftValue: this.state.value,\n    });\n  }\n}\n","export class EasyArray {\n  private defaultValue: any;\n  public items: any[];\n  constructor(items: any[], defaultValue: any) {\n    this.items = [...items];\n    this.defaultValue = defaultValue;\n  }\n\n  public update(index: number, val: any) {\n    this.items.splice(index, 1, val);\n    return this.items;\n  }\n\n  public insert(index: number) {\n    this.items.splice(index, 0, this.defaultValue);\n    return this.items;\n  }\n\n  public append() {\n    this.items.splice(this.items.length, 0, this.defaultValue);\n    return this.items;\n  }\n\n  public remove(index: number) {\n    this.items.splice(index, 1);\n    return this.items;\n  }\n}\n","import fromPairs = require('lodash/fromPairs');\n\nexport class EasyObject {\n  private defaultValue: any;\n  public items: any[];\n  constructor(value: object, defaultValue: any) {\n    // Make this thing an array\n    this.items = [...Object.entries(value)];\n    this.defaultValue = defaultValue;\n  }\n\n  public update(index: number, val: any) {\n    this.items.splice(index, 1, val);\n    return fromPairs(this.items);\n  }\n\n  public updateKey(index: number, key: any) {\n    this.items.splice(index, 1, [key, this.items[index][1]]);\n    return fromPairs(this.items);\n  }\n\n  public updateVal(index: number, val: any) {\n    this.items.splice(index, 1, [this.items[index][0], val]);\n    return fromPairs(this.items);\n  }\n\n  public insert(index: number) {\n    this.items.splice(index, 0, ['', this.defaultValue]);\n    return fromPairs(this.items);\n  }\n\n  public append() {\n    this.items.splice(this.items.length, 0, ['', this.defaultValue]);\n    return fromPairs(this.items);\n  }\n\n  public remove(index: number) {\n    this.items.splice(index, 1);\n    return fromPairs(this.items);\n  }\n}\n","import * as React from 'react';\n\nimport throttle = require('lodash/throttle');\n\nimport { DraftValue } from './DraftValue';\n\nexport interface IInputWidget {\n  value: any;\n  onChange: (value: any) => void;\n}\n\nexport interface IThrottleValue extends IInputWidget {\n  ms: number;\n  children: React.FunctionComponent<IInputWidget>;\n}\n\nexport class ThrottleValue extends React.Component<IThrottleValue> {\n  private onChange: (value: any) => void;\n\n  constructor(props: IThrottleValue) {\n    super(props);\n    this.onChange = throttle(draft => {\n      this.props.onChange(draft);\n    }, props.ms || 1000);\n  }\n\n  public render() {\n    return (\n      <DraftValue value={this.props.value} onChange={this.onChange}>\n        {({ value, onChange }) => {\n          return this.props.children({\n            value,\n            onChange,\n          });\n        }}\n      </DraftValue>\n    );\n  }\n}\n","export function parseGridTemplateAreas(rows: string[]): string[][] {\n  return rows.map(row => row.split(/\\s+/).map(x => x.trim()));\n}\n\nexport function toGridTemplateAreas(rows: string[]): string {\n  return rows.map(x => `\"${x}\"`).join(' ');\n}\n\nexport function listAreas(rows: string[]): Set<string> {\n  const parsed = parseGridTemplateAreas(rows);\n  const flatSet = new Set();\n  for (const row of parsed) {\n    for (const col of row) {\n      flatSet.add(col);\n    }\n  }\n  return flatSet;\n}\n","export const replaceWildcards = (name: string, path: string[]) => {\n  const _name = name.split('.');\n  const newpath = [];\n  for (let i = 0; i < _name.length; i++) {\n    const part = _name[i];\n    if (part === '*' || part === '?') {\n      newpath.push(path[i]);\n    } else {\n      newpath.push(part);\n    }\n    if (part === '?') break;\n  }\n  return newpath;\n};\n","export function shortName(propertyPath: string) {\n  return propertyPath.split('.').pop() as string;\n}\n","import { Dictionary } from '@stoplight/types';\nimport { deriveFormData } from './deriveFormData';\nimport { IOperation, Resolver } from './types';\n\nconst substitute = (key: string, path: string, selection: string, vars: Dictionary<string>) => {\n  const _selection = selection.split('.');\n  const _path = path.split('.');\n  return _path\n    .map((part, index) => {\n      // non-wildcards need no processing\n      if (part !== '*' && part !== '?') return part;\n      if (index < _selection.length) {\n        // Terminating wildcards are fixed points. We must use the NEW value not the one in the current selection.\n        if (part === '?') {\n          return vars[key];\n        }\n        return _selection[index];\n      } else {\n        throw new Error(`Cannot extract index \"${index}\" from selection path \"${selection}\"`);\n      }\n    })\n    .join('.');\n};\n\nexport const computeOps = (schema: any, data: any, selection: string, newFormData: any, resolver?: Resolver) => {\n  const ops: IOperation[] = [];\n  const oldFormData = deriveFormData(schema, data, selection, resolver);\n\n  const newVars: Dictionary<string> = {};\n  const oldVars: Dictionary<string> = {};\n  // processing queue for 'add' operations\n  const values: string[] = [];\n  // processing queue for 'move' operations\n  const props: string[] = [];\n  for (const key of Object.keys(schema.fields)) {\n    // Populate variable dictionaries\n    if (key.includes(`?`)) {\n      newVars[key] = newFormData[key];\n      oldVars[key] = oldFormData[key];\n    }\n    // If the form value has changed, assign it to one of two processing queues.\n    if (JSON.stringify(oldFormData[key]) !== JSON.stringify(newFormData[key])) {\n      if (key.includes('?')) {\n        props.push(key);\n      } else {\n        values.push(key);\n      }\n    }\n  }\n\n  // Update all values first using oldVars\n  for (const key of values) {\n    const rejoined = substitute(key, key, selection, oldVars);\n    ops.push({\n      op: 'add',\n      path: rejoined,\n      value: newFormData[key],\n    });\n  }\n  // Then rename nodes as needed\n  const vars = Object.assign({}, oldVars);\n  const oldSelection = selection;\n  for (const key of props) {\n    // We compute the old path using the current set of variables values\n    const oldPath = substitute(key, key, selection, vars);\n    // Then we update the current varable value and compute the new path\n    vars[key] = newVars[key];\n    const newPath = substitute(key, key, selection, vars);\n    if (oldPath !== newPath) {\n      // move node\n      ops.push({\n        op: 'move',\n        from: oldPath,\n        path: newPath,\n      });\n      // We must also update the selection now so that wildcard placeholders refer to the current state.\n      if (selection.startsWith(oldPath)) {\n        selection = selection.replace(oldPath, newPath);\n      }\n    }\n  }\n\n  // Compose consecutive move operations into a single operation, to reduce the chances of intermediate conflicts.\n  // For example:\n  //   move /todos.get -> /todos.put\n  // might overwrite an existing /todos.put object\n  // but if the full sequence is\n  //   move /todos.get -> /todos.put\n  //   move /todos.put -> /lists.put\n  // then we can combine the two operations into a single new operation:\n  //   move /todos.get -> /lists.put\n  // that does NOT have that conflict potential.\n  // For now we only consider adjacent operations, because it is much harder to prove the\n  // safety of combining interleaved operations. (We'd have to prove the intermediate operations are commutative).\n  const reducedOps = ops.reduce((acc: IOperation[], op: IOperation) => {\n    if (acc.length === 0) return [op];\n    const prev = acc[acc.length - 1];\n    if (prev.op === 'move' && op.op === 'move' && prev.path === op.from) {\n      const newOp: IOperation = {\n        op: 'move',\n        from: prev.from,\n        path: op.path,\n      };\n      acc.pop();\n      acc.push(newOp);\n    } else {\n      acc.push(op);\n    }\n    return acc;\n  }, []);\n\n  // Lastly, figure out whether this means the current selection path changes as well.\n  if (oldSelection !== selection) {\n    reducedOps.push({\n      op: 'select',\n      from: oldSelection,\n      path: selection,\n    });\n  }\n  return reducedOps;\n};\n","import get = require('lodash/get');\n\nimport { IOperation } from './types';\n\nexport const computeWarnings = (data: any, ops: IOperation[]) => {\n  // Find cases where key renames would overwrite existing keys\n  const warnings = [];\n  for (const op of ops) {\n    switch (op.op) {\n      case 'move': {\n        const exists = get(data, op.path) !== undefined;\n        if (exists) {\n          warnings.push({\n            type: 'overwrite_key',\n            op,\n          });\n        }\n        break;\n      }\n    }\n  }\n  return warnings;\n};\n","import { Dictionary } from '@stoplight/types';\nimport get = require('lodash/get');\n\n// @ts-ignore\nimport memoize from '@stoplight/memoize-one';\nimport { Resolver } from './types';\n\nconst substituteVariables = (key: string, path: string, selection: string, vars: Dictionary<string>) => {\n  const _selection = selection.split('.').filter(x => x !== '');\n  const _path = path.split('.');\n  return _path\n    .map((part, index) => {\n      if (part === '*' || part === '?') {\n        if (index < _selection.length) {\n          // A '?' indicates we can safely assume the variable name is the key under consideration\n          if (part === '?') {\n            // Update the vars dictionary\n            vars[key] = _selection[index];\n          }\n          return _selection[index];\n        } else {\n          throw new Error(`Cannot extract index \"${index}\" from selection path \"${selection}\"`);\n        }\n      }\n      // substitute known variable with its value\n      if (vars[part] !== undefined) return vars[part];\n      // otherwise do not modify it\n      return part;\n    })\n    .join('.');\n};\n\nexport const deriveFormData = memoize((schema: any, data: any, selection: string, resolver?: Resolver) => {\n  const output = {};\n  const vars = {};\n  const keys = Object.keys(schema.fields);\n\n  const unresolved = new Set(keys);\n  let lastUnresolvedSize = Infinity;\n  while (unresolved.size && unresolved.size < lastUnresolvedSize) {\n    // Keep track of whether we are making progress shrinking the unresolved set of keys\n    lastUnresolvedSize = unresolved.size;\n    for (const key of unresolved) {\n      const origPath = key;\n\n      // Substitute variable names in the path with their values, if known\n      const path = substituteVariables(key, origPath, selection, vars);\n      // Paths that include no wildcards include no unresolved variables, so they are ready\n      if (!path.includes('*') && !path.includes('?')) {\n        // Is this a value path or a key path?\n        if (origPath.includes('?')) {\n          output[key] = vars[key];\n        } else {\n          // There's one edge case where path = \"\"\n          output[key] = path === '' ? data : get(data, path);\n          if (output[key] === undefined && resolver) {\n            output[key] = resolver(path.split('.'));\n          }\n        }\n        unresolved.delete(key);\n        break;\n      }\n    }\n    if (unresolved.size === lastUnresolvedSize) {\n      throw new Error(`Unable to resolve vars: ${JSON.stringify([...unresolved.keys()])}`);\n    }\n  }\n  // Now, insert the keys in the correct order\n  const orderedOutput = {};\n  for (const key of keys) {\n    orderedOutput[key] = output[key];\n  }\n  return orderedOutput;\n});\n","export { Formtron } from './Formtron';\n\nexport { applyOps } from './applyOps';\nexport { computeOps } from './computeOps';\nexport { computeWarnings } from './computeWarnings';\nexport { deriveFormData } from './deriveFormData';\n\nexport * from './types';\n","import { createThemedModule, ICustomTheme } from '@stoplight/ui-kit';\n\nexport type themeZones = 'formtron' | string;\n\nexport type themeTypes = IFormtronTheme;\n\nexport interface IFormtronTheme extends ICustomTheme {\n  canvas?: {\n    bg: string;\n    fg: string;\n  };\n}\n\nexport const { useTheme, ThemeZone } = createThemedModule<themeZones, themeTypes>();\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;ACAA;AAEA;AACA;AACA;AACA;AAGA;AAaA;AAGA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAWA;;;;;;;;;;;;;;;AC1CA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;ACpCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;AC/BA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;ACvCA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAgBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAMA;AACA;AACA;AAEA;AACA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AA7JA;;;;;;;;;;;;;;;AC9BA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;AC/BA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;AC5CA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AAEA;AAUA;;;;;;;;;;;;;;;;ACjDA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAOA;AAIA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;ACtCA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAOA;AACA;AAIA;AACA;AACA;AAQA;;;;;;;;;;;;;;;;AC9CA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;AClCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;ACxCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;AClCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;ACjCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;;ACzBA;;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/CA;AAEA;AAIA;AACA;AAWA;AAWA;AAYA;;;;;;;;;;;;;;;ACzCA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACdA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvGA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnDA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AAEA;AAEA;AAcA;AACA;AAGA;AAEA;AACA;AAYA;AACA;AAEA;AACA;AAQA;AACA;AAEA;AACA;AAKA;AAKA;;;;;;;;;;;;;;;ACzFA;AAUA;;;;;;;;;;;;;;;ACXA;AACA;AAIA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAIA;;;;;;;;;;;;;;;AC/BA;AAKA;;;;;;;;;;;;;;;ACNA;AAEA;AAEA;AAOA;AACA;AACA;AAEA;AAGA;AAGA;;;;;;;;;;;;;;;ACrBA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAAA;AAAA;AACA;AAAA;AACA;AAQA;AAMA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;;;;;;;;;;;;;;;AC7HA;AAEA;AAUA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;;;;;;;;;;;;;;;ACtCA;AACA;AAIA;AACA;AACA;AAEA;AASA;AACA;AAEA;AAEA;AACA;AACA;AAKA;AACA;AAWA;AAaA;;;;;;;;;;;;;;;ACvDA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAKA;AACA;AAcA;AAGA;;;;;;;;;;;;;;;AC3DA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;;;;;;;;;;;;;;;AC/BA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAIA;AACA;AACA;AAKA;AACA;AAcA;;;;;;;;;;;;;;;AC9CA;AAGA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAeA;AAEA;;;;;;;;;;;;;;;ACjCA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAYA;AACA;AAGA;AACA;AAEA;AAKA;AAEA;AACA;AAaA;AAEA;AACA;AAYA;AACA;AAEA;AACA;AAQA;AACA;AAEA;AACA;AAKA;AAKA;;;;;;;;;;;;;;;;ACrHA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AASA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAGA;AACA;AAOA;AACA;AACA;AAAA;AACA;AACA;AACA;AAUA;AAgBA;AAGA;AAEA;AASA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAQA;AACA;AAWA;AAaA;AAGA;;;;;;;;;;;;;;;AC/JA;AACA;AAIA;AACA;AACA;AAEA;AAQA;AAEA;AAEA;AACA;AACA;AAKA;AACA;AAgBA;;;;;;;;;;;;;;;AC7CA;AACA;AAIA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAIA;;;;;;;;;;;;;;;AChCA;AACA;AAGA;AAEA;AAEA;AACA;AAGA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;;;;;;;;;;;;;;;;ACNA;AACA;;;;;;;;;;;;;;;ACDA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;AC3BA;AAGA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;AC1BA;AAgBA;AAAA;;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AASA;AAtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;;;;;;;;;;;;;;;AChBA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA3BA;;;;;;;;;;;;;;;ACAA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAtCA;;;;;;;;;;;;;;;ACFA;AAEA;AAEA;AAYA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AAtBA;;;;;;;;;;;;;;;AChBA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;;;;;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACbA;AACA;AACA;AAFA;;;;;;;;;;;;;;;ACCA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAcA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxHA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrBA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzEA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;ACLA;AAaA;;;;;;;;;;;;;;;;;;;A","sourceRoot":""}